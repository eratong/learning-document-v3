# 面试

## 经验资料
### 博客
<https://juejin.cn/post/7298658664196898868>

https://www.javacn.site/company/alibaba-2.html

jvm创建对象过程\
https://zhuanlan.zhihu.com/p/142614439

https://zhuanlan.zhihu.com/p/267223891

### github资料
https://github.com/Snailclimb/JavaGuide


## 面试题目
### 全家桶
springboot 如何解决跨域
```java
跨域：因为浏览器的同源策略，这些情况都会造成跨域问题
    一级域名不一样
    二级域名不一样
    http https
    端口不一样

后端采用cors解决跨域问题
    单个接口跨域可在方法上加这个注解
        @CrossOrigin("http://")
    多个接口可在webMvcConfigurer里面重写addCorsMappings
    所有接口跨域写个过滤器@Bean CorsFilter
最好的方式 采用nigix 前端访问后端域名不变，用nigix将地址转到对应后端地址，nginx没有同源策略


https://www.bilibili.com/video/BV1S94y1b7i2/?spm_id_from=333.1007.tianma.2-2-5.click&vd_source=9a81f56beba8d749b133042ede3fcf02
```

## 面试实践
### 2024-01-04 上海智观
上海 JAVA开发工程师 薪资15-20K\
职位描述\
1、计算机或相关专业本科以上学历，3年以上相关工作经验，有电商行业经验，有架构经验者优先；  
2、有良好的Java基础，对设计模式、领域模型、数据结构有较深入的理解，有JVM调优经验者优先；  
3、对主流Java技术栈有比较深入的理解，熟悉Spring MVC/iBatis/Dubbo/Spring Boot/Spring Cloud等框架和技术原理；  
4、熟练使用主流的中间件，并掌握其原理，如Redis、ElasticSearch、MQ、ZooKeeper等；  
5、熟悉Mysql、ORACLE等数据库，熟悉数据库设计，熟悉SQL语句编写与优化；  
6、熟悉Linux/Windows环境的搭建与项目的部署，以及故障排查和诊断；  
7、具有很强的学习能力，分析复杂问题和解决复杂问题的能力，有强烈的责任心和使命感，良好的沟通表达能力和团队协作能力。

视频面试 时长20分钟

问了好多啊 答案我找的不一定对哈 欢迎纠正补充 🥲

1.扣库存是先扣的缓存么
```java
方法一
并发不高、业务不复杂时可以直接用一条update语句更新数据库库存

方法二
并发高还使用数据库的话会造成大量请求阻塞，导致请求超时系统雪崩，校验库存后可以将创建订单扣库存的操作放到mq中，虽然有一定延迟性，但可以减轻数据库压力

方法三
并发高或一条update语句不能满足时可以将库存放入缓存中，用redis+lua脚本的方式扣库存
```
2.缓存扣减怎么保证原子性
```java
Redis使用单个Lua解释器去运行所有脚本，并且Redis也保证脚本会以原子性(atomic)的方式执行：当某个脚本正在运行的时候，不会有其他脚本或 Redis 命令被执行。这和使用 MULTI / EXEC 包围的事务类似
```
3.如果扣的缓存怎么保证缓存和数据库数据一致
```java
设置过期时间
定时刷新缓存
使用分布式锁保证同一时间只有一个线程去更新数据库
```

4.分布式锁使用场景
```java
① 防止重复操作：在某些场景下，比如订单处理、任务调度等，需要确保同一操作只能被执行一次。使用分布式锁可以防止多个节点同时执行同一操作，避免重复操作的问题。
② 并发控制：当多个节点同时对共享资源进行读写操作时，可能会出现数据不一致或冲突的情况。通过使用分布式锁，可以保证在同一时间只有一个节点对资源进行操作，从而实现并发控制，保证数据的一致性和正确性。
③ 缓存同步：在使用缓存的场景下，如果缓存失效时多个节点同时去更新缓存，可能会导致缓存击穿或雪崩的问题。使用分布式锁可以确保只有一个节点去更新缓存，其他节点等待获取锁后再进行操作，避免了对缓存的同时大量请求，减轻了数据库或其他后端资源的压力。
④ 限流：在高并发场景下，为了保护系统的稳定性，需要对请求进行限流。使用分布式锁可以实现简单的限流策略，例如每秒只允许一定数量的请求通过，其他请求需要等待获取锁后再进行处理。
```
5.springboot自动装配原理

```java
SpringBoot项目中有个注解@SpringBootApplication，这个注解是对三个注解进行了封装：
@SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan

其中@EnableAutoConfiguration是实现自动化配置的核心注解。
该注解通过@Import注解导入AutoConfigurationImportSelector类，这个类实现了一个导入器接口ImportSelector。

在该接口中存在一个方法selectImports，该方法的返回值是一个数组，数组中存储的就是要被导入到spring容器中的类的全类名。

在AutoConfigurationImportSelector类中重写了这个方法,该方法内部就是读取了项目的classpath路径下META-INF/spring.factories文件中的所配置的类的全类名。

在这些配置类中所定义的Bean会根据条件注解所指定的条件来决定是否需要将其导入到Spring容器中
```

6.post get 区别是什么
```java
① 传参方式
GET：参数数据会附加在URL的末尾以键值对的形式出现，请求的数据会被暴露在URL中，可见性较高。
POST：通过请求体传递数据，数据不会暴露在URL中，而是作为请求体的一部分发送给服务器。

② 请求长度限制
GET：由于数据附加在URL上，URL的长度限制了GET请求能够传递的数据量。不同的浏览器和服务器对URL长度的支持有所不同，一般来说，URL长度限制在几千个字符左右。
POST：由于数据在请求体中，没有像GET请求那样的长度限制。POST请求可以传输更大量的数据。

② 数据安全
GET：由于数据附加在URL上，GET请求的数据会被浏览器缓存和历史记录保存，且容易被拦截、修改或泄漏。因此，不适合用于传输敏感数据。
POST：由于数据在请求体中，POST请求的数据不会被缓存和保存在浏览器的历史记录中，相对来说更安全。
```

7.平常接口怎么选择哪种请求类型
```java
GET：一般用于搜索下载和筛选之类的操作（淘宝，支付宝的搜索查询都是get提交），目的是资源的获取，读取数据
POST：一般用于修改和写入数据
```

8.mysql什么情况容易出现索引失效
```java 
!=条件、like以%开头、or中有字段没有索引、条件中有索引列运算、条件字段需要类型转换、复合索引未用左列字段等等
```

9.mysql慢查询优化以及根据什么看是否用到索引
```java
用Explain去排查是否用到索引
key表示用到的索引
key_len表示索引长度
rows表示预计要检查的行数，涉及行数越少越好
```


10.mysql大小表啥的没太懂记不清了

11.一个接口请求很慢怎么排查
```java
检查日志确定慢的具体位置
检查网络，带宽、DNS解析慢等问题
检查是否有慢sql
检查代码逻辑，是否存在死循环之类的
检查是否机器达到性能瓶颈，IO、CPU等问题
等等
```

12.apollo怎么动态刷新配置
```java
可以使用@ApolloConfigChangeListener监听器 具体需要了解下源码
```

13.有用过什么配置中心么
```java
springCloud config、nacos、apollo
```

14.nacos和apollo区别

|对比项目/配置中心|apollo|nacos|
|---|---|---|
|项目背景|阿里巴巴开源项目|携程开源项目|
|功能特性|服务注册发现、配置管理等|专注于配置管理|
|开源时间|2016.5|2018.6|
|配置实时推送|支持(HTTP长轮询1s内)|支持(HTTP长轮询1s内)|
|版本管理|自动管理|自动管理|
|配置回滚|支持|支持|
|权限管理|支持|待支持|
|多集群多环境|支持|支持|
|监听查询|支持|支持|
|多语言|Go,C++,Python,Java,net,OpenAPI|Python,Java,Nodejs,OpenAPI|
|分布式高可用最小集群数量|Config2+Admin3+Portal*2+Mysql=8|Nacos*3+mysql=4|
|配置格式校验|支持|支持|
|通信协议|HTTP|HTTP|
|数据一致性|数据库模拟消息队列,Apollo定时读消息|HTTP异步通知|
|单机读(tps)|9000|15000|
|单机写(tps)|1100|1800|


15.springcloud常用组件以及各个组件作用
```java
zuul 网关组件，用于实现反向代理，将外部请求转发给对应的微服务，并提供路由、过滤、负载均衡等功能
hytrix 容错管理组件，用于处理服务之间的故障和延迟，实现服务的熔断、降级、限流等功能
ribbon 客户端负载均衡组件，用于在服务消费方进行负载均衡策略的选择和切换
eureka 服务注册与发现组件，用于实现服务治理
feign 声明式的 HTTP 客户端，用于简化服务之间的 HTTP 调用，通过注解方式定义接口并实现远程调用。
```

16.redis 数据类型
```java
String（字符串）
List（列表）
Set（集合）
Hash（散列）
Sorted Set/Zset（有序集合）
```
 
17.redis zset使用场景
```java
有序队列 
ZSet主要适用于需要排序（排行榜）的场景，如：
  粉丝列表（按关注时间排序）；
  学生成绩排名；
  文章帖子排名；
  各类榜单（如微博总热榜、分类热榜）；
```

18.redis 常用命令
```java
字符串（String）：
  设置键值对：`SET key value`
  获取值：`GET key`
  删除键值对：`DEL key`
  修改值：`SET key new_value`

列表（List）：
  在列表左侧插入元素：`LPUSH key element`
  在列表右侧插入元素：`RPUSH key element`
  获取列表范围内的元素：`LRANGE key start stop`
  删除指定元素：`LREM key count element`

哈希（Hash）：
  设置哈希字段的值：`HSET key field value`
  获取哈希字段的值：`HGET key field`
  获取所有哈希字段及值：`HGETALL key`
  删除哈希字段：`HDEL key field`

集合（Set）：
  添加元素到集合：`SADD key member`
  获取集合中的所有成员：`SMEMBERS key`
  从集合中移除元素：`SREM key member`
  判断元素是否在集合中：`SISMEMBER key member`

有序集合（Sorted Set）：
  添加带有分数的元素到有序集合：`ZADD key score member`
  获取有序集合中指定范围的元素：`ZRANGE key start stop`
  获取有序集合中成员的分数：`ZSCORE key member`
  移除有序集合中的元素：`ZREM key member`
```

19.linux查询日志命令
```java
tail -100f test.log
grep "测试" test.log | grep "测试2" 
```

### 2024-01-08 上海比升互联网技术有限公司
本来年前就该整理的，前公司项目忙不过来，办完离职被前领导喊着帮忙干了一周活，然后距离过年不到三周确实没啥岗位了，哈哈，摆烂到现在...

上海 中级Java开发工程师 13-20K

岗位职责：  
1、参与业务流程分析并根据业务需求进行JAVA服务和应用程序开发、与前端同学协作实现业务模块设计与开发联调’  
2、小组内负责开发规范的执行落地、团队工作任务协同和项目推进，当好技术带头人  
3、 关键服务和模块的设计编写， 以及代码质量的review  
4、 负责跟踪JAVA相关新技术并运用到程序开发中  
5、 负责业务中台模块的开发和维护  
任职要求：  
1、全日制大学本科及以上学历（统招为硬性要求）；计算机、通信等相关专业；三年以上工作经验；  
2、精通Java编程，熟练掌握Java基础类库、设计模式、多线程、Socket等编程经验；  
3、熟练掌握SSM、SpringMVC、 SpringCloud等常用开源框架；  
4、熟悉分布式、缓存、异步等中间件使用，起码了解Redis、消息队列、RocketMQ，了解原理者优先；  
5、精通SQL开发与优化，了解常用NoSql数据库；  
6、了解设计原则与常用的设计模式；  
7、具有模块设计能力和文档编写能力，并能带领小团队进行模块设计与开发。  
8、较强的学习能力和积极向上的精神、工作积极主动勇于承担

视频面试 时长30分钟
1.自我介绍

2.你最近或最熟悉的项目是哪一个

3.你在里面的主要职责和详细设计能说下么

4.你可以说下商品缓存是怎么设计的么\
```java
拿C端的菜单来说吧
首先需要做数据预热,也就是在项目启动或者低峰期时加载部分数据到redis缓存中，来提高缓存命中率
其次就是需要定期更新缓存，来保证缓存一致性
```

5.这里的缓存用到了几级
```java
缓存层级一般是本地缓存>redis缓存>数据库缓存
```

6.商品缓存是把所有商品都缓存么
```java
按门店级别缓存菜单商品，这样可以过滤掉大部分没用的商品
```

7.库存的并发有关注过么
```java
用分布式锁控制，提示库存繁忙
或者用的rabbitmq异步更新数据库库存，可以削峰填谷
```

8.你们的库存是直接走库的是吧
```java
有冻结库存、可售库存、安全库存这些设计，提交订单是更新redis缓存里面的冻结库存，支付成功时用mq异步更新数据库可售库存
```

9.锁定的库存是怎么设计的，就是什么时候处理冻结库存
```java
提交订单时增加冻结库存，订单支付成功或订单超时未支付时释放冻结库存
```

10.有考虑过防超卖的设计么
```java
当可售库存低于安全库存时，会发告警邮件或短信给负责人，库存操作会记录日志盘点库存
```

11.你们异步用的是rabbitmq,有考虑过消息丢失或者消息重复发送这些
```java
消息丢失
① 标记消息持久化，让消息能够在重启后恢复
② 消息重试机制
③ 设置死信队列来保证无法成功消费的消息不会被丢失
④ 监控系统，定期检查消息队列是否正常

消息重复发送
① 消费端幂等处理，保证重复发送获取的结果一致
② 采用唯一标识符，去重处理
③ 手动ack
```

12.订单有没有可能丢失呢
```java
很少应该是
```

13.订单部分发货什么逻辑
```java
商家发货后在后台点击发货，选择发货商品输入物流单号
系统设计逻辑，表方面是有订单表基础上新增订单发货商品信息表，根据商家操作商品判断部分发货还是整单发货，修改订单状态信息，保存订单发货商品信息，并异步丢消息到mq修改订单缓存信息
```

14.mysql8的版本和之前的版本有啥区别
```java
① 数据库的缺省编码将改为 utf8mb4，这个编码包含了所有 emoji 字符
② InnoDB存储引擎的改进
③ 性能和安全性增强
等等
```


15.平时你们是怎么排查线上问题
```java
在elk看日志
```

16.比如如果出现库存超卖了你们平时是怎么处理的
```java
库存不足会告警提示相关负责人
扣库存也会记录日志
```

17.mysql聚簇索引、非聚簇索引
```java
聚簇索引（Clustered Index）和非聚簇索引（Non-clustered Index）是两种不同类型的索引结构，它们在数据存储和索引构建上有一定的区别。
1.  聚簇索引（Clustered Index）：
    -   聚簇索引是一种按照索引顺序存储数据的方式，索引的叶子节点就是数据节点。
    -   聚簇索引决定了表中数据的物理存储顺序，一个表只能有一个聚簇索引。
    -   当按照聚簇索引进行查询时，MySQL 可以直接通过索引找到对应的数据行，效率较高。
2.  非聚簇索引（Non-clustered Index）：
    -   非聚簇索引存储的是索引字段的值及指向实际数据行的指针，而不是实际的数据。
    -   表中可以有多个非聚簇索引，它们并不影响数据的物理存储顺序。
    -   当按照非聚簇索引进行查询时，MySQL 首先通过索引找到对应的行指针，然后再根据指针找到数据行，需要进行两次查找操作。
```

18.mysql优化sql操作流程
```java
elpain执行计划，观察key字段有没有用到索引，len字段长度，row涉及行数，观察有没有走到索引
```

19.索引数据结构
```java
btree、hash
```

20.mysql隔离级别
```java
读未提交
读已提交
可重复读
序列化
读已提交和可重复读是比较常见的隔离级别，能够在保证数据一致性和并发性能的基础上，兼顾事务处理的效率
mysql默认隔离基本是可重复读
```

21.redis几种数据类型、使用场景
```java
string list set hash zset 
string 缓存值、分布式锁等
list 有序字符串元素集合，用于消息队列、消息列表等
set 不重复无序元素集合，可以用于标签系统之类的
zset 不重复有序元素集合，可以做排行榜
hash 字段-值的形式存储，可以用于存储门店信息等
```

22.分布式锁用的哪一种
```java
用的redis的string数据类型实现的
分布式锁可以用来防止重复点击、防止穿透等
```

23.setnx怎么保证锁过期后任务没执行完
```java
一般设置过期时间都是根据业务考虑好的，如果确实有不确定的情况，可以在执行任务期间定时更新锁过期时间，在任务执行完后释放锁
```

24.springcloud组成结构
```java
zuul hytrix熔断 ribbon限流 eureka注册中心 nacos注册中心
```

25.eureka、nacos区别
```java
nacos还可以做配置中心
```

26.系统中有用到什么设计模式
```java
单例模式、模板模式、工厂模式、
```

27.系统中有创建多线程么
```java
**不推荐使用Executors创建线程**,无界队列可能会造成内存溢出
推荐使用new ThreadPoolExecutor()的方式,根据服务器核心数自定义线程参数
```

28.多线程的核心原理有了解过么


29.了解过JVM么
```java
调优常用的-xms -xmx调整堆内存大小
```

30.线上有出现卡顿或者性能上的问题通过什么方式去看的
```java
java自带的那个**jvisualvm** ，dump那个文件 用工具去看是哪个类比较大定位位置
阿里巴巴那个arthas(阿尔萨斯)
```

31.hashmap、cucurrentHashmap区别
```java
hashmap线程不安全
cucurrenthashmap线程不安全 高并发时候使用
```

32.hashmap7和8区别
```java
数据+链表 
后来加了红黑树
```

33.平时会看源码么

34.目前有啥记得的熟悉的源码
```java
SpringBoot项目中有个注解@SpringBootApplication，这个注解是对三个注解进行了封装： @SpringBootConfiguration、@EnableAutoConfiguration、@ComponentScan 其中@EnableAutoConfiguration是实现自动化配置的核心注解。 该注解通过@Import注解导入AutoConfigurationImportSelector类，这个类实现了一个导入器接口ImportSelector。 在该接口中存在一个方法selectImports，该方法的返回值是一个数组，数组中存储的就是要被导入到spring容器中的类的全类名。 在AutoConfigurationImportSelector类中重写了这个方法,该方法内部就是读取了项目的classpath路径下META-INF/spring.factories文件中的所配置的类的全类名。 在这些配置类中所定义的Bean会根据条件注解所指定的条件来决定是否需要将其导入到Spring容器中
```

35.平时中项目中的定位和角色是什么
```java
功能开发然后带带新人啥的
```

36.你能接受项目急的时候加班么
```java
不是每天都加就还好
```

37.你有什么要问我们的么
```java
了解到是年底启动的新项目，规模是有十几个开发的，技术方面用的也是mysql、rabbitmq这些
```





### 2024-02-29 Int-speed 上海易苏信息科技有限公司
这个职位驻场在极氪，岗位长期稳定，试用期薪资不打折，目前我司在极氪驻场同事已有11位

上海 Java开发工程师 15-18k

驻场外包，试用期不打折

岗位职责：  
1. 强制:熟悉 Java 核心 AP|，熟悉 JVM 内存模型，深度理解面向对象、面向服务编程，熟  
练在日常开发中应用设计模式;  
2. 强制:熟练掌握 Springboot、Spring Cloud、Mybatis,框架，并可以灵活运用解决实际业务问题;加分项:深入理解框架底层实现;←  
3. 强制:熟练使用常用的分布式中间件技术，如负载均衡、RPC 框架、缓存、消息系统等加分项:熟悉底层实现原理，有阅读源码解决实际问题经验;  
4. 强制:了解云原生领域，熟悉 kubernetes,总体架构，以及相应的日志 监控 报警解决方案，了解常用的日志监控报警解决方案，如elk，skywalking，Prometheus 等;  
5. 强制:掌握 Linux/Unix 操作系统指令，能熟练使用命令行排查系统问题;  
6. 强制:有很强的 debug 能力，认真负责，有良好的沟通和团队协作能力;←  
7. 加分:有 Python/Shell 脚本编程经验者优先;  
8. 加分:对数据清洗、处理、数仓建设有经验者优先，有Flink、Hive、Spark、Kafka .Hbase 等大数据技术经验者优先

视频面试 20分钟


过了一个年啥都忘了，约的第二天面试，临时被调到了当天一小时后面，哈哈慌得一批被虐了

上海 Java开发工程师 15-18k

驻场极氪外包，试用期不打折

岗位职责：  
1. 强制:熟悉 Java 核心 AP|，熟悉 JVM 内存模型，深度理解面向对象、面向服务编程，熟  
练在日常开发中应用设计模式;  
2. 强制:熟练掌握 Springboot、Spring Cloud、Mybatis,框架，并可以灵活运用解决实际业务问题;加分项:深入理解框架底层实现;←  
3. 强制:熟练使用常用的分布式中间件技术，如负载均衡、RPC 框架、缓存、消息系统等加分项:熟悉底层实现原理，有阅读源码解决实际问题经验;  
4. 强制:了解云原生领域，熟悉 kubernetes,总体架构，以及相应的日志 监控 报警解决方案，了解常用的日志监控报警解决方案，如elk，skywalking，Prometheus 等;  
5. 强制:掌握 Linux/Unix 操作系统指令，能熟练使用命令行排查系统问题;  
6. 强制:有很强的 debug 能力，认真负责，有良好的沟通和团队协作能力;←  
7. 加分:有 Python/Shell 脚本编程经验者优先;  
8. 加分:对数据清洗、处理、数仓建设有经验者优先，有Flink、Hive、Spark、Kafka .Hbase 等大数据技术经验者优先

视频面试 20分钟

1. 自我介绍
2. 要不你直接介绍下项目经验，说一下主要设计的功能
> 主要负责商品、菜单、门店、库存这些模块
3. 换句话说，除了这些CRUD以外，有做过什么功能么
> 额 有点蒙 哈哈

4. 我看你这些应该都是偏商城相关的项目，除了这些增删改查的其他有设计过哪些功能

5. 那么来问点基础的吧,说说你对集合一般常用的有哪些

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30b989c44b5c45d39902962fc7ff1c2e~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=2250&h=872&s=481516&e=png&b=fefdfd)

6. 什么时候用ArrayList 什么时候用LinkedList
> 需要频繁进行随机访问操作时，应该选择 ArrayList\
> 需要频繁进行插入和删除操作时，应该选择 LinkedList


7.实际场景当中能举例子么
> 菜单商品列表可以用ArrayList\
> 购物车这种修改比较多可以用LinkedList

8.ArrayList、LinkedList区别
> ArrayList 是基于动态数组实现的，它通过数组来存储元素，并支持随机访问。当元素数量超过数组容量时，ArrayList 会自动调整容量以适应新增元素。\
> LinkedList 是基于双向链表实现的，它通过节点之间的连接来存储元素，支持快速的插入和删除操作。在 LinkedList 中，每个节点除了存储元素值外，还存储了指向前后节点的引用。

9.ArrayList数组初始化有固定长度的，ArrayList基本上也没有长度限制，那是如何实现的
> 在 Java 中，ArrayList 的内部实现是基于数组的动态扩容机制来实现长度的动态变化。虽然 ArrayList 在初始化时需要指定初始容量，但它并不限制实际存储元素的数量，可以动态地根据需要进行扩容。\
> 当我们向 ArrayList 中添加元素时，如果当前元素个数已经达到了内部数组的容量上限，ArrayList 会执行扩容操作。具体扩容的过程如下：
> 1. 当要添加的元素个数超过当前内部数组的容量时，ArrayList 会创建一个新的更大容量的数组。
> 2. 然后将原来数组中的元素复制到新数组中。
> 3. 最后，原来的数组会被丢弃，新数组取代原来的数组成为 ArrayList 内部的存储结构。
> 
>这样，通过动态扩容的方式，ArrayList 可以灵活地存储任意数量的元素，并且在添加元素时最坏情况下的时间复杂度仍然是 O(n)。ArrayList 内部的扩容机制允许我们在开发过程中不需要考虑数组大小的限制，从而更加方便地管理和操作数据。


10.ArrayList、LinkedList线程上是安全的么
> 线程不安全

11.如果想做一个线程安全的怎么做到
> **使用 Collections 工具类的 synchronizedList 方法**： 可以通过 `Collections.synchronizedList(List<T> list)` 方法来创建一个线程安全的 List 集合，该方法返回的集合会对所有对集合的修改操作进行同步处理，从而保证线程安全。\
> **使用并发集合类**： Java 提供了一些并发集合类，如 CopyOnWriteArrayList、ConcurrentLinkedQueue 等，它们是专门设计用来在多线程环境下进行高效并发操作的集合类。\
> **使用线程安全的锁机制**： 可以使用 synchronized 关键字或者 Lock 接口提供的锁机制来保证对 ArrayList 和 LinkedList 的访问操作是原子的，从而保证线程安全。

12.Map说一下对这个的了解，一般用到的都有哪些
类                      | 并发性 | 有序性          | 底层数据结构         | 初始容量 | 负载因子 | 实例化方式 | 一致性  | k/v是否可为null |
| ---------------------- | --- | ------------ | -------------- | ---- | ---- | ----- | ---- | ----------- |
| HashMap                | 不支持 | 无序           | 数组+链表/红黑树      | 16   | 0.75 | 懒加载   | -   | k/v可为null   |
| LinkedHashMap          | 不支持 | 有序（插入序或者访问序） | 数组+单向链表+双向链表   | -   | -   | -    | -   | k/v可为null   |
| TreeMap                | 不支持 | 自然序（左小右大）    | 红黑树            | -   | -   | -    | -   | 仅v能为null    |
| ThreadLocalMap         | 不支持 | 无序           | 数组             | 16   | 0.75 | 懒加载   | -   | 仅v能为null    |
| HashTable              | 支持  | 无序           | 数组加链表          | 11   | 0.75 | 初始化创建 | 强一致性 | 均不能为null    |
| ConcurrentHashMap(1.7) | 支持  | 无序           | 分段锁+数组+链表      | 16   | 0.75 | 懒加载   | 强一致性 | 均不能为null    |
| ConcurrentHashMap(1.8) | 支持  | 无序           | 数组+链表/红黑树+特殊结构 | 16   | 0.75 | 懒加载   | 弱一致性 | 均不能为null    |
| ConcurrentSkipListMap  | 支持  | 自然序(左小右大)    | 跳跃表            | -   | -   | -    | 弱一致性 | 均不能为null

13.concurrentHashMap如何实现线程安全
> **分段锁机制**： ConcurrentHashMap 内部采用了分段锁（Segment）的机制，将整个哈希表分成多个小的段（Segment），每个段都可以看作是一个独立的 HashMap。不同的线程可以同时访问不同的段，从而减小了并发冲突的范围，提高了并发度。\
> **读操作的无锁并发访问**： ConcurrentHashMap 允许多个线程同时进行读操作，这些读操作是无锁的并发访问，因为每个段内的操作都是线程安全的。\
> **使用 CAS 操作**： 在写操作（插入、删除等）时，ConcurrentHashMap 使用了 CAS（Compare and Swap）操作来保证线程安全。CAS 是一种乐观锁的方式，它允许线程在不加锁的情况下尝试更新内存中的变量，并通过比较预期值和当前值是否相等来确定是否更新成功。\
> **扩容策略**： ConcurrentHashMap 在扩容时采用了一种不会阻塞读操作的扩容策略，通过将旧的数据迁移到新的段中，从而避免了扩容过程中对读操作的影响。
    
14.了解AQS么
> AQS（AbstractQueuedSynchronizer）是 Java 中用于实现同步器的抽象框架。它提供了一种基于 FIFO 等待队列的机制，可以帮助开发者实现各种复杂的同步器，如 ReentrantLock、Semaphore、CountDownLatch 等。AQS 主要包含以下两个核心部分：
> 1.  **状态管理**： AQS 通过一个 int 类型的状态来管理同步状态，开发者可以使用 getState()、setState(int newState) 等方法来操作这个状态。不同的同步器可以根据具体需求自定义状态的含义和变化规则。
> 1.  **等待队列**： AQS 使用一个 FIFO 的等待队列来管理等待获取同步状态的线程。当一个线程尝试获取同步状态但失败时，会被加入到等待队列中，进入阻塞状态；当同步状态可用时，AQS 会从等待队列中唤醒部分或所有线程，让它们重新竞争获取同步状态。
通过继承 AQS 并重写其中的几个关键方法，开发者可以相对容易地实现自定义的同步器。其中最重要的方法包括：
> -   **tryAcquire(int arg)** ：尝试获取同步状态，成功返回 true，失败返回 false。
> -   **tryRelease(int arg)** ：尝试释放同步状态。
> -   **tryAcquireShared(int arg)** ：尝试获取共享同步状态。
> -   **tryReleaseShared(int arg)** ：尝试释放共享同步状态。
    
15.聊一下springcloud五大神兽指的哪五个
> **Eureka**： Eureka 是 Spring Cloud 中的服务注册与发现组件，实现了微服务架构中的服务注册与发现功能。通过 Eureka，各个微服务可以注册自己的信息，并通过 Eureka 服务器来发现其他微服务，实现了服务之间的通信和协作。\
> **Zuul**： Zuul 是 Spring Cloud 中的网关组件，提供了统一的访问入口和路由转发功能。通过 Zuul，可以实现请求的过滤、路由、负载均衡等功能，为微服务架构提供了统一的访问控制和管理。\
> **Ribbon**： Ribbon 是 Spring Cloud 中的客户端负载均衡组件，用于在客户端实现负载均衡。通过 Ribbon，可以实现对请求的负载均衡策略的选择，从而提高系统的性能和可靠性。\
> **Hystrix**： Hystrix 是 Spring Cloud 中的容错管理组件，用于处理分布式系统中的故障和延迟问题。通过 Hystrix，可以实现服务的降级、断路器、线程隔离等功能，保证系统的稳定性和可靠性。\
> **Feign**： Feign 是 Spring Cloud 中的声明式服务调用组件，简化了服务之间的调用和依赖关系。通过 Feign，可以通过定义接口的方式来调用其他服务，避免了繁琐的 HTTP 请求和参数传递，提高了开发效率。

16.服务注册中心做了哪些事情
> **服务注册**： 微服务启动时，会向注册中心注册自己的服务信息，包括服务名、IP 地址、端口号等。注册中心会将这些信息存储起来，以便其他服务可以发现和调用该服务。\
> **服务发现**： 其他微服务需要调用某个服务时，会向注册中心查询该服务的信息。注册中心会返回符合条件的服务实例列表，供调用方选择合适的实例进行调用。\
> **服务健康检查**： 注册中心会定期检查已注册的服务实例的健康状态，例如检查服务是否正常运行、是否能够及时响应请求等。如果某个服务实例出现故障或不可用，注册中心会将其标记为不可用，避免请求发送到异常的服务上。\
> **负载均衡**： 注册中心可以提供负载均衡的功能，根据一定的策略将请求分发给多个服务实例，以实现负载均衡和提高系统的性能和可用性。\
> **服务元数据管理**： 注册中心通常还会管理服务的元数据信息，如版本号、环境信息、运行状态等，帮助开发者更好地管理和监控微服务系统。

17.网关功能
> **路由转发**： 网关作为整个系统的入口，负责接收外部请求并将其转发到对应的微服务实例。通过配置路由规则，网关可以将不同的请求路由到不同的微服务上，实现统一的访问入口。
> **请求过滤**： 网关可以对进入系统的请求进行过滤和处理，包括身份验证、请求日志记录、请求参数校验等。通过请求过滤，可以增强系统的安全性和稳定性。
> **负载均衡**： 网关可以集成负载均衡功能，将请求均衡地分发给多个微服务实例，提高系统的性能和可用性。通过负载均衡，可以避免单一服务实例的性能瓶颈问题。
> **熔断与降级**： 网关可以实现熔断和降级功能，当后端服务出现故障或响应缓慢时，网关可以进行限流、熔断或降级处理，保证系统的稳定性和可靠性。
> **安全认证**： 网关可以集成认证和授权功能，对请求进行身份验证和权限校验，确保只有合法的用户可以访问系统资源。通过安全认证，可以保护系统免受恶意攻击

18.当前端一个请求过来，正常上线部署的项目会是怎么一个流程，一个请求的生命周期\
比如CLB证书认证啊、走到网关啊、到数据库什么的

19.jvm内存结构有了解么
> **程序计数器（Program Counter Register）** ： 程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。每个线程都有独立的程序计数器，确保线程切换后能够恢复到正确的执行位置。\
> **Java 虚拟机栈（JVM Stack）** ： Java 虚拟机栈用于存储方法执行时的局部变量、操作数栈、动态链接、方法出口等信息。每个方法在执行时会创建一个栈帧（Stack Frame），栈帧包含了方法的参数、局部变量和操作数栈等信息。\
> **本地方法栈（Native Method Stack）** ： 本地方法栈类似于 Java 虚拟机栈，只不过它为 native 方法（使用 JNI 调用的方法）服务。\
>  **堆内存（Heap）** ： Java 堆是 Java 虚拟机管理的最大一块内存区域，用于存储对象实例。堆内存可以被所有线程共享，是 GC（Garbage Collection） 进行垃圾回收的主要区域。\
>  **方法区（Method Area）** ： 方法区用于存储类的结构信息、常量、静态变量、即时编译器编译后的代码等数据。在 Java 8 及之前的版本，方法区是 HotSpot 虚拟机实现的永久代（Permanent Generation）。从 Java 8 开始，方法区被元空间（Metaspace）取代。\
>  **运行时常量池（Runtime Constant Pool）** ： 运行时常量池是方法区的一部分，用于存放编译期生成的各种字面量和符号引用。\
>  **直接内存（Direct Memory）** ： 直接内存并不是 JVM 内部的一部分，但是被频繁地用于 NIO 等操作中。直接内存通过本地方法库来分配内存，而不是通过 JVM 进行分配，因此不受 JVM 堆大小限制。

20.oom时怎么排查，比如现在有一个项目部署在linux上，cpu彪的很高怎么排查
> 1.看日志\
> 2.如果有设置了 JVM 的参数 `-XX:+HeapDumpOnOutOfMemoryError`，则当发生 OOM 错误时会生成堆转储文件（Heap Dump），可以使用工具分析堆转储文件，查看内存中的对象分布情况，找出内存占用较大的对象或者内存泄漏的情况。\
> 3.检查代码是否有内存泄漏

21.linux常用命令
> 1.  **文件和目录操作**：
>   -   `ls`：列出目录内容
>   -   `cd`：切换目录
>   -   `pwd`：显示当前工作目录
>   -   `mkdir`：创建新目录
>   -   `rm`：删除文件或目录
>   -   `cp`：复制文件或目录
>   -   `mv`：移动文件或目录
>   -   `touch`：创建空文件或更新文件时间戳
>
>2.  **文本处理**：
>
>    -   `cat`：查看文件内容
>    -   `grep`：在文件中搜索指定模式
>    -   `head`：显示文件头部内容
>    -   `tail`：显示文件尾部内容
>    -   `wc`：统计文件行数、字数和字符数
>
>3.  **系统管理**：
>
>    -   `ps`：显示进程状态
>    -   `top`：实时显示系统中各个进程的资源占用情况
>    -   `kill`：终止进程
>    -   `df`：显示磁盘空间利用情况
>    -   `free`：显示内存使用情况
>
>4.  **权限管理**：
>
>    -   `chmod`：修改文件权限
>    -   `chown`：修改文件所有者
>    -   `chgrp`：修改文件所属组
>
>5.  **网络相关**：
>
>    -   `ping`：测试网络连接
>    -   `ifconfig`：显示或配置网络接口信息
>    -   `netstat`：显示网络状态和统计信息
>    -   `ssh`：远程登录到另一台主机
>
>6.  **压缩和解压缩**：
>
>    -   `tar`：打包和解包文件
>    -   `gzip`：压缩文件
>    -   `unzip`：解压缩文件


22.垃圾回收这块有了解吗
>在 JVM 中，垃圾回收器（Garbage Collector）负责执行垃圾回收的工作，它会定期检查程序中不再使用的对象，并将这些对象所占用的内存标记为可回收。常见的垃圾回收算法包括：
>1.  **标记-清除算法**（Mark and Sweep）：该算法首先标记所有活跃对象，然后清除所有未被标记的对象，释放它们所占用的内存空间。但是标记-清除算法可能会产生内存碎片。
>2.  **复制算法**（Copying）：该算法将堆内存分为两块，每次只使用其中一块，将活跃对象复制到另一块内存中，然后清除旧的内存块中所有对象。这样可以避免内存碎片问题。
>3.  **标记-整理算法**（Mark and Compact）：该算法结合了标记-清除和复制算法的优点，先标记并整理活跃对象，然后将它们紧凑地排列在一起，清除未使用的对象。

23.商城做一个抽奖活动，lv1 lv2 lv3的用户分别抽不同的奖池，怎么用设计模式
> 1.  **工厂方法模式**（Factory Method Pattern）：
>    -   定义一个抽奖活动工厂接口（`AbstractFactory`），包含创建不同等级用户奖池的方法。
>    -   实现不同等级用户奖池的具体工厂类，如 `Level1Factory`、`Level2Factory` 和 `Level3Factory`，分别负责创建对应用户等级的奖池对象。
>    -   奖池对象可以定义一个统一的抽奖方法，供用户调用进行抽奖操作。
> 2.  **策略模式**（Strategy Pattern）：
>    -   定义一个抽奖策略接口（`PrizePoolStrategy`），包含抽奖方法。
>    -   实现不同等级用户奖池的具体策略类，如 `Level1PrizePool`、`Level2PrizePool` 和 `Level3PrizePool`，每个类实现自己等级用户的抽奖逻辑。
>    -   在工厂方法中，根据用户等级选择对应的奖池工厂，然后根据具体的策略类来创建奖池对象。




### 2024-03-05 万氪睿速 20-99人

上海 Java开发工程师 14-20K

人力外包至甲方公司：栈略数据
工作时间：9:30-6:30
地点：上海市徐汇区龙爱路7号芒果广场B座（潇湘楼）5楼

一、岗位职责 
1、负责保司对接需求的分析、梳理和开发； 
2、负责TPA各个保司对接项目的维护，能够快速响应业务、运营和保司人员反馈的问题； 
3、负责对线上问题进行排错并能快速落地可行的解决方案； 
4、负责联调对接工作，处理保司对接联调过程中的沟通、问题跟进和问题处理； 
5、负责代码的单元测试、定期的code review，保证代码的持续优化，保证代码的可维护性和健壮性； 
二、任职要求 
1. 计算机相关专业，统招全日制本科以上学历，5年工作经验左右； 
2. 熟练掌握Java，SpringBoot，Spring Cloud，Hibernate/Mybatis, Maven, GIT等； 
3. 熟练掌握Restful Service的开发，熟悉SOA，熟悉Micro-Service； 
4. 有扎实的SQL功底，熟悉MySQL数据库； 
5. 具有良好的计算机基础，了解数据结构、算法、操作系统、设计模式等； 
6. 对业界相关技术的形态、发展有自己的理解，对当前流行的开源产品和技术保持开放和探索精神； 
7. 良好的编程习惯和团队协作精神，注重质量，工作效率高；思维敏捷，虚心好学，领悟能力强，抗压能力强； 
8. 有复杂业务项目对接经验优先


### 2024-03-06 橘宜 100-500人


### 2024-03-07 德诚珠宝集团有限公司

Java开发工程师 13-20K

集团背景：自研非外包
1、学历要求：全日制统招（学信网可查）；
2、经验要求：目前招聘2年及以上经验，3-5年优先；
3、应聘流程：发送简历及学信网截图—推荐用人部门—安排现场面试（当天完成机试或笔试+面试）
4、德诚集团是珠宝运营商，集团员工全国4K+，信息中心60人左右，项目类型以2B为主的供应链相关场景开发。欢迎投递简历！

1、您到时过来直接导航：静安区江场西路中铁中环时代广场6号楼801。
2、一号线：汶水路-下地铁走路约15分钟，骑自行车约5分钟。
3、现场面试流程：技术岗位有笔试或者机试测试+面试。（当天一趟差不多就可以完成面试流程，特殊情况才需要走两趟）
4、到现场后前台没人可直接进入公司，或打面试邀约中的电话哦。


岗位职责：
1、能够理解产品需求，进行代码开发，保证代码质量、可靠性和性能达标；
2、参与企业级产品后端架构设计工作，接口设计、实现及文档编写；
3、按时保质的完成工作，配合测试组完成项目测试工作，系统交付工作；
4、对项目实施提供支持，参与产品设计，与前端工程师一同探讨技术方案。
任职要求：
1、大专及以上学历，计算机相关专业，3年左右Java研发经验；
2、精通JAVA开发，熟悉常见的设计模式，有系统设计经验；
3、熟悉TCP/IP协议，进程间通讯编程，熟悉Unix/Linux下常用工具及架构设计方法；
4、熟悉Spring框架，熟练掌握SpirngBoot、Springcloud,SpringMVC、HibernateMyBatis等；
5、熟练掌握Oracle和MySQL应用开发及优化，熟悉NoSQL存储，熟练掌握Redis并理解其适用场景；
6、熟悉RPC框架、消息队列框架、分布式存储系统，了解分布式协调服务Zookeeper；
7、熟悉常用的项目构建工具及版本管理工具，如Maven.Git.SVN；
8、积极主动，认真负责，头脑灵活，具有良好的沟通和团队协作能力。



设计模式
tcp/ip
rpc



### 2024-03-12 噗遥科技外包

成立日期 2024-02-04 20-99人

中级java开发工程师 13-15K 注册资金3w

岗位名称：JAVA工程师
1、计算机相关专业，4年以上开发经验；
2、Java基础扎实，熟悉集合、I/O、多线程，了解JVM工作原理，熟悉java领域常用框架的使用和原理，如：SpringBoot、SpringCloud等；
3、有分布式系统、微服务等开发经验；
4、熟悉Mysql、Redis，对数据库有较强的设计能力，同时熟悉SQL优化；
5、熟悉ElasticSearch，有系统升级功能开发相关经验优先；
6、具备良好的沟通能力、团队合作精神以及较强的学习能力，善于分析解决问题。



### 2024-03-13 拜耳作物科学

后端工程师 - Java 12-15K·13薪  30人左右  后端两个人

电话面试

岗位职责：
1. 按照业务需求完成系统的开发，自测，上线； 
2. 负责对所开发系统不断优化，确保核心技术指标不断改善； 
3. 负责提升系统的用户体验，对性能、稳定性等不懈追求。  
基本要求：
1. 1 -3 年以上Java及WEB应用系统设计开发经验，具备良好的代码能力以及编程规范； 
2. 精通Java，多线程编程，消息系统，数据库，分布式应用等技术，了解SOA框架的使用；
3. 熟悉Spring、Spring Boot、 Redis、MyBatis、Hibernate等常用框架和类库 ； 
4. 做事积极主动，沟通能力强，对工作认真负责，有较强责任心和事业心，具有良好的计划和创新的能力；  
5. 有中大型系统研发经验优先；有高性能、高可用性系统设计、研发、优化经验尤佳。



1. spring beanfactory factorybean
beanfactory ioc的核心接口 主要用来管理bean对象的创建、配置和管理

factorybean用于创建复杂的bean对象或允许在bean创建过程中执行特定的逻辑

BeanFactory作为Spring容器的核心接口，负责管理bean对象的生命周期和依赖关系；而FactoryBean则提供了一种扩展机制，允许用户自定义bean的创建过程，并可以在创建过程中做一些额外的处理。

2. spring 循环依赖怎么处理
https://blog.csdn.net/cy973071263/article/details/132676795

三级缓存

Spring通过三级缓存解决了循环依赖，
其中一级缓存为单例池（singletonObjects），
二级缓存为早期曝光对象earlySingletonObjects，
三级缓存为早期曝光对象工厂（singletonFactories）。
当A、B两个类发生循环引用时，在A完成实例化后，就使用实例化后的对象去创建一个对象工厂，并添加到三级缓存中，
如果A被AOP代理，那么通过这个工厂获取到的就是A代理后的对象，
如果A没有被AOP代理，那么通过这个工厂获取到的就是A实例化的对象。
当A进行属性注入时，会去创建B，同时B又依赖了A，所以创建B的同时又会去调用getBean(a)来获取需要的依赖，此时的getBean(a)会从缓存中获取，waqxc第一步，先获取到三级缓存中的工厂；第二步，调用对象工工厂的getObject方法来获取到对应的对象，得到这个对象后将其注入到B中。紧接着B会走完它的生命周期流程，包括初始化、后置处理器等。当B创建完后，会将B再注入到A中，此时A再完成它的整个生命周期。至此，循环依赖结束！

简单点说，Spring解决循环依赖的思路就是：当A的bean需要B的bean的时候，提前将A的bean放在缓存中（实际是将A的ObjectFactory放到三级缓存），然后再去创建B的bean，但是B的bean也需要A的bean，那么这个时候就去缓存中拿A的bean，B的bean创建完毕后，再回来继续创建A的bean，最终完成循环依赖的解决。Spring 利用 三级缓存 巧妙地将出现 循环依赖 时的 AOP 操作 提前到了 属性注入 之前（通过第三级缓存实现的），解决了循环依赖问题。


3. kafka 数据是存在哪的 
  分区日志文件

4. 库存超卖

5. redis数据类型以及使用

6. 分布式锁setnx 怎么保证原子性

7. redis lua怎么保证原子性

8. redis和数据库怎么保证数据一致性

9. redis集群有哪些
一、主从
适合单体架构项目

二、哨兵
适合单体架构项目
主机宕机需要手动切换主服务器，不方便水平扩容
每个节点存储的数据一样

三、redis cluster集群 
完全去中心化 没有中心节点 hash槽分配方式
方便水平扩容
分布式存储、每个节点存储的数据不一样

1.  redis 大key问题
  内存占用过大
  影响持久化
  查询IO很慢

2.  跳跃表原理

3.  数据库分表有哪些逻辑

4.  数据库优化

5.  什么情况会导致不走索引

6.  like %为啥放左边为啥不走索引

7.   怎么解决死锁

8.   注册中心还了解哪些

9.  平时会学习什么以外的知识

10. maven冲突

11. redis持久化机制


redis脑裂问题



### 2024-03-13 上海牧客网络科技有限公司

中级java工程师 13-20K   要了17左右 外贸转型做AI

线上面试 一轮 后面可能还有现场面试

岗位职责：
1、参与系统及业务层面的架构设计，根据业务规划及技术规划制定技术方案； 
2、负责相关功能模块的需求分析、设计、开发和单元测试工作，以及相关技术文档编写； 
3、维护和完善软件产品和系统，快速定位并修复相关缺陷，及时解决出现的问题；
 
岗位要求：
1、本科及以上学历，计算机、软件工程相关专业，3年以上Java开发经验； 
2、熟悉分布式后端服务开发流程和规范，熟练使用Spring Cloud、Spring Boot等框架并对框架原理有一定了解；
3、掌握数据库的理论知识，熟练使用MySQL、mongoDB等主流数据库；熟悉常见的开源分布式中间件、缓存(Redis)、消息队列(kafka)等，具备相关的应用开发经验；
4、熟悉常用业务架构的设计，具备良好的编程能力和代码风格，对模块化和架构有较深理解；有分布式、高并发、高负载、高可用性平台架构设计经验；
5、熟悉Linux下的DevOps，熟悉敏捷开发流程，具备较强的解决问题、分析问题的能力；具有独立开发和设计的能力；

mongoDB  kafka


1. 删除多条重复数据 只保留其中一条
```sql
DELETE FROM your_table 
WHERE id NOT IN (
    SELECT MIN(id) 
    FROM your_table 
    GROUP BY other_field
);
```
2. redis数据类型和使用

3. 超卖问题

4. 


### 2024-03-14 德国电信咨询

后端开发工程师 15-20K·13薪

1.计算机相关专业毕业，3年以上相关工作经验
2.熟悉主流Java开发框架，如Spring, Spring MVC, Mybatis, SpringBoot等
3.掌握数据库相关知识，熟悉Mysql数据库，了解非结构数据库，如MongoDB，具有一定的SQL调优经验
4.熟悉Linux系统，熟悉SVN、GIT等代码版本管理工具，熟悉Maven等项目工具
5.熟悉消息中间件，至少有一种消息中间件使用经验，如kafka、rocketmq
6.了解设计模式并能应用
7.对分布式系统开发有一定经验，有互联网开发经验优先
8.基础知识牢固，有良好的团队合作精神，善于独立思考，乐于分享


应该属于一面人事面 需要驻场开发 大众汽车供应链啥的





### 2024-03-14 超达盛源

超达盛源是超达集团投资控股的健康科技公司，简称“超达健康”。与金赛战略合作，提供儿童内分泌、大儿科意准患者/准患者管理长期解决方案。
超达盛源成立于2023年，注册于广州市，注册资本1000万人民币；现有员工200余人。长春新区发展集团（国有企业）成员，由长春超达投资集团控股；拥有国家颁发的互联网医院资质；是从事健康科技推广和运营服务为主的企业。

java中高级开发工程师 20-23K·14薪

1、 能独立负责业务板块，按照业务需求进行业务需求分析、评审和设计
2、 进行软件详细设计和编码实现
3、 相关文档编写、整理和维护
4、 参与软件系统的方案讨论、技术调研、系统分析、重构、优化
任职资格:
1、计算机或其他相关专业毕业，本科以上学历；
2、5年及以上java开发工作经验；
3、精通Java编程语言，熟练运用SpringMVC,mybatis，SpringBoot等Java EE框架
4、具有较强的逻辑思维以及系统分析和文档编写能力，良好的编程风格，能快速学习和掌握新技术
6. 了解SpringCloud等微服务框架
7．熟悉Mysql数据库，熟悉Tomcat，Nginx
9 . 熟练使用svn,git等项目管理工具；
10. 具备较强的自学能力，团队精神及抗压能力，思路清晰，善于思考，能独立分析和解决问题；


希望提前准备一下java基础知识 包括 jvm 集合 锁 spring mysql



### 2024-03-15 怪兽

高级研发工程师-JAVA 17-24K·14薪

要的17k左右

1. 负责供应链资产业务后端日常开发工作；
2. 能独立负责业务板块，按照业务需求进行业务需求分析、评审和设计；
3. 参与软件系统的方案讨论、技术调研、系统分析、重构、优化；
4. 优化现有系统，保持系统稳定，参与解决疑难问题；
任职资格
1、本科学历，3年以上开发经验，具备较好的文档编写能力及良好的编码风格；
2、熟悉软件开发流程，具备良好的表达和沟通能力
3、熟练掌握Spring boot，mybatis等框架，对并发包、垃圾回收、jvm等有深刻理解；
4、熟悉Mysql、Redis、Elasticsearch等数据库和缓存技术；
5、良好的敬业精神、 团队合作精神和高度的责任感、乐观开朗、沟通顺畅。

















|方法|描述用途
|---|---|
|GET|	【获取资源】本质就是发送一个请求来取得服务器上的某一资源。资源通过一组HTTP头和呈现数据（如HTML文本，或者图片或者视频等）返回给客户端。GET请求中，永远不会包含呈现数据。 即GET请求只用来向服务器获取资源，而GET请求本身不应该携带任何呈现数据。<br>1. 登录时GET获取服务器数据库用户名和密码进行验证。<br> 2.下载文本、图片、音视频等时获取服务器资源。
|POST|	【传输实体文本】向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在POST请求体中。POST 请求可能会导致新的资源的建立或已有资源的修改。<br>1. 提交用户注册信息。<br>2. 提交修改的用户信息。
|PUT|	【传输文件】从客户端向服务器传送的数据取代指定的文档的内容，即指定上传资源存放路径。这个方法比较少见。HTML表单也不支持这个。本质上来讲， PUT和POST极为相似，都是向服务器发送数据，但它们之间有一个重要区别，PUT通常指定了资源的存放位置，而POST则没有，POST的数据存放位置由服务器自己决定。<br>如一个用于提交博文的URL，/addBlog。如果用PUT，则提交的URL会是像这样的”/addBlog/abc123”，其中abc123就是这个博文的地址。而如果用POST，则这个地址会在提交后由服务器告知客户端。目前大部分博客都是这样的。显然，PUT和POST用途是不一样的。具体用哪个还取决于当前的业务场景。
|DELETE|	【删除文件】请求服务器删除指定的资源。<br>基本上这个也很少见，不过还是有一些地方比如amazon的S3云服务里面就用的这个方法来删除资源。
|HEAD|	【获得报文首部】类似于 GET 请求，只不过返回的响应中没有具体的内容，用于获取报头。欲判断某个资源是否存在，我们通常使用GET，但这里用HEAD则意义更加明确。<br>1. 向服务器获取某些易过期或丢失大型文件时，可用HEAD方式查询资源是否存在。
|OPTIONS|	【询问支持的方法】客户端询问服务器可以提交哪些请求方法。这个方法很有趣，它用于获取当前URL所支持的方法。若请求成功，则它会在HTTP头中包含一个名为“Allow”的头，值是所支持的方法，如“GET, POST”。<br> 极少使用。
|PATCH|	【局部更新文件】是对 PUT 方法的补充，用来对已知资源进行局部更新 。<br>极少使用。
|TRACE|	【追踪路径】回显服务器收到的请求，客户端可以对请求消息的传输路径进行追踪，TRACE方法是让Web服务器端将之前的请求通信还给客户端的方法。主要用于测试或诊断。<br>极少使用。
|CONNECT|	【要求用隧道协议连接代理】HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。CONNECT方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL（安全套接层）和TLS（传输层安全）协议把通信内容加密后经网络隧道传输。




https://blog.csdn.net/qq_41805567/article/details/129111183

Spring Boot的自动装配实际上是从`META-INF/spring.factories`文件中获取到对应的需要进行自动装配的类，并生成相应的Bean对象，然后将它们交给Spring容器进行管理

@springbootApplication注解流程图
![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/373360406d254ddc9b4f4e5a03c1ae45~tplv-k3u1fbpfcp-jj-mark:0:0:0:0:q75.image#?w=1404&h=642&s=81480&e=png&b=ffffff)

> @SpringBootConfiguration : 标注在某个类上，表示这是一个Spring Boot的配置类；
> @ComponentScan : 配置扫描路径，用于加载使用注解格式定义的bean
> @EnableAutoConfiguration : 开启自动装配功能
>
> > @AutoConfigurationPackage 指定了`指定了默认的包规则`就是将主程序类所在包及所有子包下的组件扫描到Spring容器中;
@Import(AutoConfigurationImportSelector.class) : 通过 @Import 注解导入 `AutoConfigurationImportSelector`类，然后通过该类的`selectImports`方法去读取`MATE-INF/spring.factories`文件中配置的组件的全类名，并按照一定的规则过滤掉不符合要求的组件的全类名，将剩余读取到的各个组件的全类名集合返回给IOC容器并将这些组件注册为bean




varchar(50)和varchar(500)有什么区别？内存空间都一样的话，我为什么不都用varchar(500)呢？
数据库里有四个字段,id,a,b,c，其中id是主键，有两个联合索引，ab，ac下面几个查询都会用到哪些索引？
select * from t where a=xx and b=xx and c==xx;
select * from t where a=xx and c=xx and b==xx;
select * from t where a=xx and (b=xx or b==xx);
读取已提交和可重复读级别下的共享锁和排他锁有什么区别吗？
  共享锁允许多个事务同时读取同一行数据，在读取已提交级别下会立即释放锁，而在可重复读级别下会保持锁定状态。(共享锁是为了防止读过程中数据被修改)
  排他锁在事务修改数据时使用，它会阻止其他事务对被锁定的行进行读取或修改，在两个级别下都会保持锁定状态。
你自己如何实现一个分布式锁？可重入怎么实现？
分布式锁加锁过程中network timeout了怎么办？假如已经加锁成功呢？
分布式锁在Redis主从部署的情况下，主从节点延时怎么办？
怎么评估Redission实现分布锁所需的hash的结构的大小呢？
父线程用synchronized对某段代码加锁，子线程能获取到锁吗？
JVM调优，说说你有实战的经历吗？
内存泄露了怎么办？怎么排查？
有哪些Full GC的原因？（说了几个，但是一直在追问）
算法考了一道原创题完全二叉树的复原，查了一下，力扣和牛客上都没有，当时是用BFS写的，复盘了一下，和二叉树的序列化这道题里的反序列化过程比较类似，应该大体上写的没问题。





遇到的困难

一、门店距离计算


一、索引失效
之前做评价中心，刚开始联查三四张表没啥问题，联查完用distinct去重之后分页，但是当时不记得是加啥条件了，加上会索引失效然后查询还慢，如果要整个功能按条件分类，分成用不同的sql去做分页改动太大了，当时就临时把查询字段减少成只有索引字段，然后再根据分页完的主键去二次查询其他需要的字段

二、加购后下面购物车的提示，提示如果购买了88折会员的话能优惠xx元这个功能，因为促销计算本身涉及到各种活动，还涉及到三方的系统比较慢，然后当时就用了线程池+CompletableFuture 异步促销计算，然后在主线程获取两种情况下计算结果
```java
 @Bean("customExecutor")
    public ExecutorService taskExecutor() {
        ExecutorService customExecutor = new ThreadPoolExecutor(
                ShoppingCartConstant.CORE_POOL_SIZE,
                ShoppingCartConstant.MAXIMUM_POOL_SIZE,
                0L, TimeUnit.MILLISECONDS,
                new LinkedBlockingQueue<>(200),
                new CustomThreadFactory(),
                (r, e) -> log.error("全家快中台服务出现异常情况：shopping-cart r " + r.toString() + " rejected from " + e.toString()));
        return customExecutor;
    }

  CompletableFuture<BaseResponse> promotionInfo = CompletableFuture.supplyAsync(() ->
                        getPromotionInfo(vo, reqVO, transNo, promotionCalcRequestVO, finalArrraySkus, finalCartProductVos, zxAddlDiscRespVO), customExecutor).exceptionally(throwable -> {
                    log.error("集享商品促销计算异常", throwable);
                    return new BaseResponse(Version.VERSION_1, AppletStatusCode.STATUS_CODE_213.getStatusCode(), AppletStatusCode.STATUS_CODE_213.getMessage());
                });
                CompletableFuture<BaseResponse> zXpromotionInfo = CompletableFuture.supplyAsync(() ->
                        getPromotionInfo(newVo, newReqVO, UUID.randomUUID().toString(), newPromotionCalcRequestVO, finalArrraySkus,
                                finalCartProductVos,zxAddlDiscRespVO), customExecutor).exceptionally(throwable -> {
                    log.error("尊享商品促销计算异常", throwable);
                    return new BaseResponse(Version.VERSION_1, AppletStatusCode.STATUS_CODE_213.getStatusCode(), AppletStatusCode.STATUS_CODE_213.getMessage());
                });
                CompletableFuture<BaseResponse> finalResult = promotionInfo.thenCombine(zXpromotionInfo, (baseResponse, baseResponse2) -> {
                    if (!AppletStatusCode.STATUS_CODE_100.getStatusCode().equals(baseResponse.getCode())
                            || !AppletStatusCode.STATUS_CODE_100.getStatusCode().equals(baseResponse2.getCode())) {
                        return baseResponse;
                    }
                    // 开通尊享88折本单节省金额
                    BigDecimal saveAmount = newVo.getTotalDiscount().subtract(vo.getTotalDiscount());
                    vo.setZxSaveAmt(saveAmount.compareTo(BigDecimal.ZERO) == 1 ? saveAmount : BigDecimal.ZERO);
                    return baseResponse;
                });
                try {
                    return finalResult.get();
                } catch (Exception e) {
                    log.error("获取促销结果发生异常", e);
                    return new BaseResponse(Version.VERSION_1, AppletStatusCode.STATUS_CODE_213.getStatusCode(), AppletStatusCode.STATUS_CODE_213.getMessage());
                }
                
```